# Ansible Playbook Documentation

Detailed documentation of Ansible playbooks used for application deployment.

## Table of Contents

- [Overview](#overview)
- [Playbook Structure](#playbook-structure)
- [Inventory Configuration](#inventory-configuration)
- [Deployment Playbook](#deployment-playbook)
- [Variables and Secrets](#variables-and-secrets)
- [Extending Playbooks](#extending-playbooks)

---

## Overview

The TerraCloud infrastructure uses **Ansible** for application deployment to VMs. This approach provides:

- **Flexibility**: Complex deployment logic with conditions and loops
- **Idempotency**: Safe to run multiple times
- **Rollback capability**: Automatic rollback on failure
- **SSH-based**: No agents required on target VMs
- **Extensibility**: Easy to add new tasks and plays

### Why Ansible?

**Advantages for IaaS deployments**:
- ✅ SSH-based (no pre-installed agents needed)
- ✅ Supports complex deployment workflows
- ✅ Built-in modules for Docker, MySQL, systemd, etc.
- ✅ Can manage multiple VMs simultaneously
- ✅ Rollback logic with rescue blocks

**Use cases**:
- Deploy containers to VMs
- Run database migrations
- Configure services
- Health checks and verification
- Multi-step deployments with rollback

---

## Playbook Structure

```
ansible/
├── ansible.cfg                 # Ansible configuration
├── inventories/                # Environment inventories
│   ├── qa.yml                 # QA environment hosts
│   └── prod.yml               # Production environment hosts
└── playbooks/
    └── deploy.yml             # Application deployment playbook
```

### Configuration File

**Location**: `ansible/ansible.cfg`

```ini
[defaults]
host_key_checking = False
inventory = ./inventories
remote_user = azureuser
private_key_file = ~/.ssh/terracloud_deploy
retry_files_enabled = False
stdout_callback = yaml

[ssh_connection]
ssh_args = -o ControlMaster=auto -o ControlPersist=60s
pipelining = True
```

**Key settings**:
- `host_key_checking = False`: Skip SSH host key verification (first connection)
- `remote_user = azureuser`: Default SSH user
- `pipelining = True`: Faster execution
- `stdout_callback = yaml`: Better readable output

---

## Inventory Configuration

### Static Inventory

**QA inventory** (`inventories/qa.yml`):

```yaml
all:
  children:
    app_servers:
      hosts:
        vm-1:
          ansible_host: 20.123.45.67  # VM public IP
      vars:
        ansible_user: azureuser
        ansible_ssh_private_key_file: ~/.ssh/terracloud_deploy
        env_name: qa
        acr_name: terracloudacr
        app_image_tag: "1.2.3"
```

**Production inventory** (`inventories/prod.yml`):

```yaml
all:
  children:
    app_servers:
      hosts:
        vm-1:
          ansible_host: 40.234.56.78  # VM public IP
      vars:
        ansible_user: azureuser
        ansible_ssh_private_key_file: ~/.ssh/terracloud_deploy
        env_name: prod
        acr_name: terracloudacr
        app_image_tag: "1.2.3"
```

### Dynamic Inventory

**Generated by GitHub Actions** workflow:

```yaml
# Created dynamically in app-deploy.yml
- name: Create dynamic inventory
  run: |
    cat > ansible/inventories/dynamic/${{ env.ENV_NAME }}.yml <<EOF
    all:
      children:
        app_servers:
          hosts:
            vm-1:
              ansible_host: $VM_IP
          vars:
            ansible_user: azureuser
            ansible_ssh_private_key_file: ~/.ssh/id_rsa
            env_name: ${{ env.ENV_NAME }}
            acr_name: $ACR_NAME
            app_image_tag: ${{ env.IMAGE_TAG }}
    EOF
```

**Benefits**:
- Always up-to-date VM IPs from Terragrunt outputs
- No manual inventory updates needed
- Environment-specific image tags

### Inventory Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `ansible_host` | VM public IP address | `20.123.45.67` |
| `ansible_user` | SSH username | `azureuser` |
| `ansible_ssh_private_key_file` | SSH private key path | `~/.ssh/terracloud_deploy` |
| `env_name` | Environment name | `qa` or `prod` |
| `acr_name` | Azure Container Registry name | `terracloudacr` |
| `app_image_tag` | Docker image tag to deploy | `1.2.3` |

---

## Deployment Playbook

**Location**: `playbooks/deploy.yml`

### Playbook Overview

```yaml
---
- name: Deploy Application to VM
  hosts: app_servers
  gather_facts: yes
  become: yes

  vars:
    container_name: "app"
    app_port: 80
    health_check_retries: 10
    health_check_delay: 10

  tasks:
    # Deployment tasks...
```

### Playbook Flow

```
1. Setup Phase
   ├─ Gather facts about target VM
   └─ Become root for privileged operations

2. Pre-Deployment
   ├─ Remove existing container (if exists)
   └─ Wait for memory to stabilize

3. Image Management
   ├─ Pull new image from ACR
   └─ Clean up old images (save disk space)

4. Container Deployment
   ├─ Start new container with env vars
   ├─ Configure network (Traefik)
   └─ Set restart policy (always)

5. Health Checks (commented out)
   └─ Wait for application to respond

6. Rollback (commented out)
   └─ Revert to previous image on failure
```

### Task Breakdown

#### Task 1: Remove Existing Container

```yaml
- name: Remove existing container
  community.docker.docker_container:
    name: "{{ container_name }}"
    state: absent
  ignore_errors: yes
```

**Purpose**: Stop and remove old container before deploying new one

**Module**: `community.docker.docker_container`

**Parameters**:
- `name`: Container name (from variable)
- `state: absent`: Remove container
- `ignore_errors`: Continue even if container doesn't exist

#### Task 2: Wait for Memory

```yaml
- name: Wait for memory to stabilize
  pause:
    seconds: 5
```

**Purpose**: Allow memory to be freed after container removal

**Why?**: Important on low-memory VMs (512MB) to prevent OOM errors

#### Task 3: Pull Docker Image

```yaml
- name: Pull Docker image from ACR
  community.docker.docker_image:
    name: "{{ acr_name }}.azurecr.io/app"
    tag: "{{ app_image_tag }}"
    source: pull
    force_source: yes
  register: image_pull
```

**Purpose**: Download Docker image from ACR

**Module**: `community.docker.docker_image`

**Parameters**:
- `name`: Image repository
- `tag`: Specific version to pull
- `source: pull`: Pull from registry
- `force_source: yes`: Always pull even if cached
- `register: image_pull`: Save result for later use

**Authentication**: Uses Azure managed identity (configured in cloud-init)

#### Task 4: Clean Up Old Images

```yaml
- name: Clean up old Docker images
  shell: docker image prune -af --filter "until=24h"
  ignore_errors: yes
```

**Purpose**: Free disk space by removing old images

**Filter**: Only removes images older than 24 hours

**Why?**: Keeps recent images for quick rollback

#### Task 5: Start New Container

```yaml
- name: Start new container
  community.docker.docker_container:
    name: "{{ container_name }}"
    image: "{{ acr_name }}.azurecr.io/app:{{ app_image_tag }}"
    state: started
    restart_policy: always
    networks:
      - name: app_app-net
    labels:
      "traefik.enable": "true"
      "traefik.http.routers.app.rule": "HostRegexp(`.*`)"
      "traefik.http.services.app.loadbalancer.server.port": "80"
    env:
      APP_ENV: "{{ env_name }}"
      APP_KEY: "{{ lookup('env', 'APP_KEY') }}"
      DB_HOST: "{{ lookup('env', 'DB_HOST') }}"
      DB_PORT: "{{ lookup('env', 'DB_PORT') }}"
      DB_DATABASE: "{{ lookup('env', 'DB_DATABASE') }}"
      DB_USERNAME: "{{ lookup('env', 'DB_USERNAME') }}"
      DB_PASSWORD: "{{ lookup('env', 'DB_PASSWORD') }}"
  register: container_start
```

**Purpose**: Start application container with configuration

**Module**: `community.docker.docker_container`

**Key configurations**:
- **Network**: Connects to `app_app-net` (Traefik network)
- **Labels**: Traefik routing configuration
- **Restart policy**: `always` (auto-restart on failure)
- **Environment variables**: Database connection, app config

**Environment variable lookup**:
- `lookup('env', 'DB_HOST')`: Reads from environment
- Set in GitHub Actions workflow or local shell

#### Task 6: Health Checks (Currently Disabled)

```yaml
# Commented out in current version
- name: Wait for container to be healthy
  uri:
    url: "http://localhost:{{ app_port }}/api/health"
    status_code: 200
  register: health_check
  until: health_check.status == 200
  retries: "{{ health_check_retries }}"
  delay: "{{ health_check_delay }}"
```

**Purpose**: Verify application is responding

**Retries**: 10 attempts with 10 second delays (total 100 seconds)

**To enable**: Uncomment this task in `deploy.yml`

#### Rollback Block (Currently Disabled)

```yaml
# Commented out in current version
rescue:
  - name: Rollback - find previous image
    shell: docker images --format "{{.Repository}}:{{.Tag}}" | grep "{{ acr_name }}.azurecr.io/app" | grep -v "{{ app_image_tag }}" | head -1
    register: previous_image
    ignore_errors: yes

  - name: Rollback to previous version
    docker_container:
      name: "{{ container_name }}"
      image: "{{ previous_image.stdout }}"
      state: started
      restart_policy: always
    when: previous_image.stdout is defined and previous_image.stdout != ""

  - name: Fail the deployment
    fail:
      msg: "Deployment failed and was rolled back."
```

**Purpose**: Automatic rollback if deployment fails

**Process**:
1. Find previous Docker image on VM
2. Start container with previous image
3. Fail the playbook with error message

**To enable**: Uncomment the `rescue` block

---

## Variables and Secrets

### Playbook Variables

**Defined in playbook** (`vars` section):

```yaml
vars:
  container_name: "app"
  app_port: 80
  health_check_retries: 10
  health_check_delay: 10
```

**Defined in inventory**:

```yaml
vars:
  env_name: qa
  acr_name: terracloudacr
  app_image_tag: "1.2.3"
```

### Environment Variables

**Set before running playbook**:

```bash
export APP_KEY="base64:..."
export DB_HOST="terracloud-qa-mysql.mysql.database.azure.com"
export DB_PORT="3306"
export DB_DATABASE="terracloud_qa"
export DB_USERNAME="dbadmin"
export DB_PASSWORD="password"
export DB_CONNECTION="mysql"
```

**Accessed in playbook** via `lookup('env', 'VAR_NAME')`:

```yaml
env:
  APP_KEY: "{{ lookup('env', 'APP_KEY') }}"
  DB_HOST: "{{ lookup('env', 'DB_HOST') }}"
```

### GitHub Actions Integration

**Environment variables set in workflow**:

```yaml
- name: Deploy application
  env:
    DB_HOST: ${{ secrets.DB_HOST }}
    DB_PORT: ${{ secrets.DB_PORT }}
    DB_DATABASE: ${{ secrets.DB_DATABASE }}
    DB_USERNAME: ${{ secrets.DB_USERNAME }}
    DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
    APP_KEY: ${{ secrets.APP_KEY }}
  run: |
    ansible-playbook -i inventories/dynamic/qa.yml playbooks/deploy.yml
```

---

## Extending Playbooks

### Adding Database Migrations

**Uncomment or add migration task**:

```yaml
- name: Run database migrations
  community.docker.docker_container_exec:
    container: "{{ container_name }}"
    command: php artisan migrate --force
  register: migration_result

- name: Display migration output
  debug:
    var: migration_result.stdout
```

### Adding Pre-Deployment Tasks

**Example: Backup database before deployment**:

```yaml
- name: Backup database
  shell: |
    docker exec {{ container_name }} \
      php artisan backup:run
  ignore_errors: yes
```

### Adding Post-Deployment Tasks

**Example: Cache clearing**:

```yaml
- name: Clear application cache
  community.docker.docker_container_exec:
    container: "{{ container_name }}"
    command: php artisan cache:clear

- name: Optimize application
  community.docker.docker_container_exec:
    container: "{{ container_name }}"
    command: php artisan optimize
```

### Adding Multiple VMs

**Update inventory** to include multiple hosts:

```yaml
all:
  children:
    app_servers:
      hosts:
        vm-1:
          ansible_host: 20.123.45.67
        vm-2:
          ansible_host: 20.123.45.68
        vm-3:
          ansible_host: 20.123.45.69
```

**Playbook runs on all hosts automatically**:
```yaml
- name: Deploy Application to VM
  hosts: app_servers  # Targets all VMs in app_servers group
```

**Serial deployment** (one at a time):

```yaml
- name: Deploy Application to VM
  hosts: app_servers
  serial: 1  # Deploy to one VM at a time
```

### Adding Load Balancer Configuration

**Example: Update load balancer after deployment**:

```yaml
- name: Add VM to load balancer
  azure.azcollection.azure_rm_loadbalancer:
    resource_group: terracloud-prod-rg
    name: terracloud-lb
    backend_address_pools:
      - name: backend-pool
        backend_ip_configurations:
          - "{{ ansible_host }}"
  delegate_to: localhost
```

### Custom Health Checks

**Application-specific checks**:

```yaml
- name: Check database connectivity
  uri:
    url: "http://{{ ansible_host }}/api/db-health"
    status_code: 200
  retries: 5
  delay: 10

- name: Check Redis connectivity
  uri:
    url: "http://{{ ansible_host }}/api/redis-health"
    status_code: 200
  retries: 5
  delay: 10
```

---

## Running Playbooks

### Basic Usage

```bash
cd ansible

# Run deployment
ansible-playbook -i inventories/qa.yml playbooks/deploy.yml
```

### Advanced Options

**Verbose output**:
```bash
ansible-playbook -i inventories/qa.yml playbooks/deploy.yml -v    # Verbose
ansible-playbook -i inventories/qa.yml playbooks/deploy.yml -vv   # More verbose
ansible-playbook -i inventories/qa.yml playbooks/deploy.yml -vvv  # Very verbose
```

**Dry run** (check mode):
```bash
ansible-playbook -i inventories/qa.yml playbooks/deploy.yml --check
```

**Limit to specific hosts**:
```bash
ansible-playbook -i inventories/qa.yml playbooks/deploy.yml --limit vm-1
```

**Skip tags**:
```bash
ansible-playbook -i inventories/qa.yml playbooks/deploy.yml --skip-tags health_check
```

**Pass extra variables**:
```bash
ansible-playbook -i inventories/qa.yml playbooks/deploy.yml \
  -e "app_image_tag=1.2.4" \
  -e "force_deploy=true"
```

---

## Testing Playbooks

### Test Connectivity

```bash
ansible -i inventories/qa.yml all -m ping
```

### Test Commands

```bash
# Check Docker status
ansible -i inventories/qa.yml all -a "docker ps"

# Check disk space
ansible -i inventories/qa.yml all -a "df -h"

# Check memory
ansible -i inventories/qa.yml all -a "free -h"
```

### Syntax Check

```bash
ansible-playbook playbooks/deploy.yml --syntax-check
```

### List Tasks

```bash
ansible-playbook -i inventories/qa.yml playbooks/deploy.yml --list-tasks
```

---

## Best Practices

### 1. Use Idempotent Tasks

Tasks should be safe to run multiple times:
```yaml
# Good - idempotent
- name: Ensure Docker is installed
  apt:
    name: docker.io
    state: present

# Bad - not idempotent
- name: Install Docker
  shell: apt-get install -y docker.io
```

### 2. Handle Errors Gracefully

```yaml
- name: Optional task
  shell: some_command
  ignore_errors: yes

- name: Required task with retry
  shell: critical_command
  retries: 3
  delay: 5
```

### 3. Use Variables for Flexibility

```yaml
# Good - configurable
- name: Start container
  community.docker.docker_container:
    name: "{{ container_name }}"
    image: "{{ acr_name }}.azurecr.io/app:{{ app_image_tag }}"

# Bad - hardcoded
- name: Start container
  community.docker.docker_container:
    name: "app"
    image: "terracloudacr.azurecr.io/app:1.2.3"
```

### 4. Add Descriptive Task Names

```yaml
# Good
- name: Pull Docker image from ACR (version {{ app_image_tag }})

# Bad
- name: Pull image
```

### 5. Use Blocks for Rollback

```yaml
- name: Deployment block
  block:
    # Deployment tasks
  rescue:
    # Rollback tasks
  always:
    # Cleanup tasks
```

---

## Next Steps

- **Deploy application**: See [DEPLOYMENT.md](DEPLOYMENT.md)
- **Workflows**: See [WORKFLOWS.md](WORKFLOWS.md)
